[const关键字]
1. const常量和宏定义常量的区别：
    1.1 宏定义发生时机在预处理时，做字符串的替换，const常量是在编译时，本质还是一个变量，只是用const关键字限定之后，赋予只读属性。
    1.2 宏定义没有类型，不做任何类型检查；const常量有具体的类型，在编译期会执行类型检查。

2.  指针常量 --> 指针是常量 --> int * const pa = &a; // 指向不可变，所指数据可变。const pa  常量指针（const pointer）
    常量指针 --> 常量的指针 --> const int * pb = &b; // 指向可变，所指数据不可变。const int 指向常量的指针（pointer to const）
    const int * const pc = &c;//指向和指向的值皆不能进行修改

[new/delete表达式] --> C语言中使用malloc/free函数，C++使用new/delete表达式;
1. new表达式的返回值是相应类型的指针，malloc返回值是void*；
2. new表达式申请空间时可以直接初始化, malloc申请的空间不会进行初始化；
3. new会根据相应类型自动获取空间大小;
4. delete只是回收了指针指向的空间，但这个指针变量依然还在，需要手动将指针置空；
5. delete[]可以释放数组空间，释放时会自动调用析构函数，对应new int[5]() 。

[引用] --> 引用是一个已定义（即先初始化）变量的别名 <引用一经绑定，无法更改绑定> --> int &ref = a; // ref是a的别名，可以直接用ref来访问a的值，也可以修改a的值。
1. 引用必须初始化，指针可以不初始化；
2. 引用不能修改绑定，但是指针可以修改指向；
3. 在代码层面对引用本身取址取到的是变量的地址，但是对指针取址取到的是指针变量本身的地址；
```cpp
void func(const int & x){//保证了引用传递的安全性
    x = 100; //error
}
```
4. 不要返回局部变量的引用，另外，如果返回的是一个堆空间变量的引用，那么这个函数调用一次就会new一次，非常容易造成内存泄露。

[默认参数与函数重载] --> 同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
1. 函数参数的数量、类型、顺序任一不同则可以构成重载, 只有返回类型不同，参数完全相同，是不能构成重载的;
2. 通常是将默认值的设置放在声明中而不是定义 ，函数参数赋默认值从右向左（严格）

[类与对象] --> 由对象抽象出类，对象是类的实例，类可以包含数据成员、成员函数、构造函数、析构函数等。
1. 函数声明放在头文件，函数定义放在实现文件中
2. 构造函数 --> 完成对象成员变量的初始化及其他操作（如为指针成员动态申请内存）--> 数据成员的初始化与声明顺序一致
3. 内存对齐 --> 除数组外，其他类型的数据成员以较大数据成员所占空间的倍数进行对齐。内存对齐还与数据成员的声明顺序有关。
4. 析构函数 --> 释放对象申请的内存 --> 一般不定义，由编译器自动生成，但如果类中含有指针成员，需要手动释放内存。
5. 拷贝构造函数 --> 复制对象时调用，默认情况下，编译器会自动生成，但如果类中含有指针成员，需要手动实现。

