[const关键字]
1. const常量和宏定义常量的区别：
    1.1 宏定义发生时机在预处理时，做字符串的替换，const常量是在编译时，本质还是一个变量，只是用const关键字限定之后，赋予只读属性。
    1.2 宏定义没有类型，不做任何类型检查；const常量有具体的类型，在编译期会执行类型检查。

2.  指针常量 --> 指针是常量 --> int * const pa = &a; // 指向不可变，所指数据可变。const pa  常量指针（const pointer）
    常量指针 --> 常量的指针 --> const int * pb = &b; // 指向可变，所指数据不可变。const int 指向常量的指针（pointer to const）
    const int * const pc = &c;//指向和指向的值皆不能进行修改

[new/delete表达式] --> C语言中使用malloc/free函数，C++使用new/delete表达式;
1. new表达式的返回值是相应类型的指针，malloc返回值是void*；
2. new表达式申请空间时可以直接初始化, malloc申请的空间不会进行初始化；
3. new会根据相应类型自动获取空间大小;
4. delete只是回收了指针指向的空间，但这个指针变量依然还在，需要手动将指针置空；
5. delete[]可以释放数组空间，释放时会自动调用析构函数，对应new int[5]() 。

[引用] --> 引用是一个已定义（即先初始化）变量的别名 <引用一经绑定，无法更改绑定> --> int &ref = a; // ref是a的别名，可以直接用ref来访问a的值，也可以修改a的值。
1. 引用必须初始化，指针可以不初始化；
2. 引用不能修改绑定，但是指针可以修改指向；
3. 在代码层面对引用本身取址取到的是变量的地址，但是对指针取址取到的是指针变量本身的地址；
```cpp
void func(const int & x){//保证了引用传递的安全性
    x = 100; //error
}
```
4. 不要返回局部变量的引用，另外，如果返回的是一个堆空间变量的引用，那么这个函数调用一次就会new一次，非常容易造成内存泄露。

[默认参数与函数重载] --> 同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
1. 函数参数的数量、类型、顺序任一不同则可以构成重载, 只有返回类型不同，参数完全相同，是不能构成重载的;
2. 通常是将默认值的设置放在声明中而不是定义 ，函数参数赋默认值从右向左（严格）



[面试-C++中函数重载的概念*]
C++ 允许多个函数拥有相同的名字，只要它们的函数参数的数量、类型、顺序任一不同不同就可以，这就是函数重载（Function Overloading）。
其实现原理是名字改编（参数的类型，个数或顺序），编译器会生成唯一的标识符来区分不同的重载函数。
借助重载，一个函数名可以有多种用途。
函数重载是指在同一作用域内，可以有一组具有相同函数名，不同参数列表的函数，这组函数被称为重载函数。
重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，对于程序的可读性有很大的好处。

