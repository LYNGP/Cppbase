### cppbase02

#### 1. 类的定义
C++用类来描述对象，类是对现实世界中相似事物的抽象，比如同是“双轮车”的摩托车和自行车，有共同点，也有许多不同点。
“车”类是对摩托车、自行车、汽车等相同点的提取与抽象。

由对象抽象出类, 由类实例化出对象

类的定义分为两个部分：
1. 数据，相当于现实世界中的属性，称为数据成员;
2. 对数据的操作，相当于现实世界中的行为，称为成员函数。

```C++
class MyClass{//类的定义
    //……
    void myFunc(){}  //成员函数 成员函数可以在类内部完成定义，也可以在类内部只进行声明，在类外部完成定义。
    int _a;          //数据成员
};//一定要有分号


//类也可以先声明，后完成定义
class MyClass2;//类的声明

class MyClass2{//类的定义
    //……
};//分号不能省略
```

**C 的 struct 与 C++ 的 class 的区别：**
C中的struct只能是一些变量的集合体，可以封装数据但不能隐藏数据，而且成员不能是函数，要使用函数只能使用函数指针的方式。
访问权限限制、继承性、构造析构都没有。
事实上，C中struct的这种封装属于广义上的封装。
面向对象的封装是指隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；
将抽象得到的数据和操作数据的方法相结合，形成“类”。

函数声明放在头文件，函数定义放在实现文件中

#### 2. 对象的构造与销毁

[构造函数]
构造函数是用来初始化数据成员的
构造函数的形式：
没有返回值，即使是void也不能有；
函数名与类名相同，再加上函数参数列表。
构造函数在对象创建时自动调用，用以完成对象成员变量等的初始化及其他操作(如为指针成员动态申请内存等)

[内存对齐]
除数组外，其他类型的数据成员中，以较大的数据成员所占空间的倍数去对齐。
内存对齐还与数据成员的声明顺序有关。
原因：
CPU 对内存的读取不是连续的，而是分成块读取的，若不进行内存对齐，可能需要做两次内存访问，性能会大打折扣；而进行过内存对齐仅需要一次访问。

[指针数据成员]
```c++
#include "cplusplus.hpp"
using namespace std;

class Computer
{
public:
    Computer(const char *brand, double price)
        : _brand(new char[strlen(brand) + 1]), _price(price)
    {
        strcpy(_brand, brand);
    }
    void print()
    {
        fmt::print("品牌: {}, 价格: {}\n", _brand, _price);
    }

    ~Computer()
    {

        if (_brand)
        {
            delete[] _brand;
            _brand = nullptr;
        }
    }

private:
    char *_brand;
    double _price;
};
void test0()
{
    Computer pc("Dell", 2000);
    pc.print();
}

int main(int argc, char *argv[])
{
    test0();
    return 0;
}

```
[析构函数]
对象在销毁时，一定会自动调用析构函数（析构函数默认情况下 ，系统也会自动提供一个）
析构函数清理对象的数据成员申请的资源（堆空间）—— 析构函数并不负责清理数据成员(系统自动完成)
析构函数只有一个（不能重载）

构造函数和析构函数的调用时机（重点）

对于全局定义的对象，每当程序开始运行，在主函数 main 接受程序控制权之前，就调用构造函数创建全局对象，整个程序结束时，自动调用全局对象的析构函数。
对于局部定义的对象，每当程序流程到达该对象的定义处就调用构造函数，在程序离开局部对象的作用域时调用对象的析构函数。
对于关键字 static 定义的静态对象，当程序流程到达该对象定义处调用构造函数，在整个程序结束时调用析构函数。
对于用 new 运算符创建的堆对象，每当创建该对象时调用构造函数，在使用 delete 删除该对象时，调用析构函数。

[拷贝构造函数]
| 概念      | 定义           | 关键点                             | 生活例子      |
| ------- | ------------ | ------------------------------- | --------- |
| 拷贝构造函数  | 用同类对象初始化新对象  | 参数必须是 `const` 引用                | 抄写员复制笔记本  |
| 浅拷贝     | 只复制指针地址      | 多个对象共享同一块内存                     | 两把钥匙开同一把锁 |
| 深拷贝     | 复制指针指向的内容    | 每个对象有自己的内存副本                    | 各自有自己的房间  |
| 引用符号    | 必须加，否则无限递归   | `ClassName(ClassName&)` ❌       | —         |
| `const` | 推荐加，防止修改临时对象 | `ClassName(const ClassName&)` ✅ | —         |

```c++

//默认默认拷贝构造（浅拷贝）等价于：
Shallow(const Shallow &other) : name(other.name) {}
//深拷贝：（当对象中有指针成员时，使用深拷贝，拷贝指针指向的内容）
Deep(const Deep &other) : name(new char[strlen(other.name) + 1])
{
    strcpy(name, other.name);
}

```
```c++
class Modern {
private:
    string name;  // 不需要手动深拷贝，string 会自动处理
    vector<int> data;  // 同样自动处理
    unique_ptr<int[]> buffer;  // 智能指针自动管理内存
public:
    // 编译器生成的默认拷贝构造函数就足够了
    // Modern(const Modern& other) = default;
};
```

| 成员类型             | 背后机制           | 拷贝时的实际效果               | 
| --------------------------- | ------------------------- | -------------------------- | 
| `string name;`| 拷贝构造函数/赋值运算符内部自带“深拷贝”|会重新分配堆内存，把字符数组完整复制一份| 
| `vector<int> data;` | 同上，标准容器都实现了深拷贝| 会把底层 `new[]` 出来的整段元素复制到新内存 | 
| `unique_ptr<int[]> buffer;` | **不可拷贝**（delete 了拷贝构造/赋值） | 编译器直接禁止对象拷贝，从根本上杜绝“浅拷贝灾难”  | 
